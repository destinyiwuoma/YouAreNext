// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var test = require('tap').test;
var sys = require('sys');

///--- Globals

var BerWriter;

var BerReader;


///--- Tests

test('load library', function(t) {
  BerWriter = require('../../lib/index').BerWriter;
  t.ok(BerWriter);
  t.ok(new BerWriter());
  t.end();
});


test('write byte', function(t) {
  var writer = new BerWriter();

  writer.writeByte(0xC2);
  var ber = writer.buffer;

  t.ok(ber);
  t.equal(ber.length, 1, 'Wrong length');
  t.equal(ber[0], 0xC2, 'value wrong');

  t.end();
});


test('write 1 byte int', function(t) {
  var writer = new BerWriter();

  writer.writeInt(0x7f);
  var ber = writer.buffer;

  t.ok(ber);
  t.equal(ber.length, 3, 'Wrong length for an int: ' + ber.length);
  t.equal(ber[0], 0x02, 'ASN.1 tag wrong (2) -> ' + ber[0]);
  t.equal(ber[1], 0x01, 'length wrong(1) -> ' + ber[1]);
  t.equal(ber[2], 0x7f, 'value wrong(3) -> ' + ber[2]);

  t.end();
});


test('write 2 byte int', function(t) {
  var writer = new BerWriter();

  writer.writeInt(0x7ffe);
  var ber = writer.buffer;

  t.ok(ber);
  t.equal(ber.length, 4, 'Wrong length for an int');
  t.equal(ber[0], 0x02, 'ASN.1 tag wrong');
  t.equal(ber[1], 0x02, 'length wrong');
  t.equal(ber[2], 0x7f, 'value wrong (byte 1)');
  t.equal(ber[3], 0xfe, 'value wrong (byte 2)');

  t.end();
});


test('write 3 byte int', function(t) {
  var writer = new BerWriter();

  writer.writeInt(0x7ffffe);
  var ber = writer.buffer;

  t.ok(ber);
  t.equal(ber.length, 5, 'Wrong length for an int');
  t.equal(ber[0], 0x02, 'ASN.1 tag wrong');
  t.equal(ber[1], 0x03, 'length wrong');
  t.equal(ber[2], 0x7f, 'value wrong (byte 1)');
  t.equal(ber[3], 0xff, 'value wrong (byte 2)');
  t.equal(ber[4], 0xfe, 'value wrong (byte 3)');

  t.end();
});


test('write 4 byte int', function(t) {
  var writer = new BerWriter();

  writer.writeInt(0x7ffffffe);
  var ber = writer.buffer;

  t.ok(ber);

  t.equal(ber.length, 6, 'Wrong length for an int');
  t.equal(ber[0], 0x02, 'ASN.1 tag wrong');
  t.equal(ber[1], 0x04, 'length wrong');
  t.equal(ber[2], 0x7f, 'value wrong (byte 1)');
  t.equal(ber[3], 0xff, 'value wrong (byte 2)');
  t.equal(ber[4], 0xff, 'value wrong (byte 3)');
  t.equal(ber[5], 0xfe, 'value wrong (byte 4)');

  t.end();
});


test('write boolean', function(t) {
  var writer = new BerWriter();

  writer.writeBoolean(true);
  writer.writeBoolean(false);
  var ber = writer.buffer;

  t.ok(ber);
  t.equal(ber.length, 6, 'Wrong length');
  t.equal(ber[0], 0x01, 'tag wrong');
  t.equal(ber[1], 0x01, 'length wrong');
  t.equal(ber[2], 0xff, 'value wrong');
  t.equal(ber[3], 0x01, 'tag wrong');
  t.equal(ber[4], 0x01, 'length wrong');
  t.equal(ber[5], 0x00, 'value wrong');

  t.end();
});


test('write string', function(t) {
  var writer = new BerWriter();
  writer.writeString('hello world');
  var ber = writer.buffer;

  t.ok(ber);
  t.equal(ber.length, 13, 'wrong length');
  t.equal(ber[0], 0x04, 'wrong tag');
  t.equal(ber[1], 11, 'wrong length');
  t.equal(ber.slice(2).toString('utf8'), 'hello world', 'wrong value');

  t.end();
});

test('write buffer', function(t) {
  var writer = new BerWriter();
  // write some stuff to start with
  writer.writeString('hello world');
  var ber = writer.buffer;
  var buf = new Buffer([0x04, 0x0b, 0x30, 0x09, 0x02, 0x01, 0x0f, 0x01, 0x01,
     0xff, 0x01, 0x01, 0xff]);
  writer.writeBuffer(buf.slice(2, buf.length), 0x04);
  ber = writer.buffer;

  t.ok(ber);
  t.equal(ber.length, 26, 'wrong length');
  t.equal(ber[0], 0x04, 'wrong tag');
  t.equal(ber[1], 11, 'wrong length');
  t.equal(ber.slice(2, 13).toString('utf8'), 'hello world', 'wrong value');
  t.equal(ber[13], buf[0], 'wrong tag');
  t.equal(ber[14], buf[1], 'wrong length');
  for (var i = 13, j = 0; i < ber.length && j < buf.length; i++, j++) {
    t.equal(ber[i], buf[j], 'buffer contents not identical');
  }
  t.end();
});

test('write string array', function(t) {
  var writer = new BerWriter();
  writer.writeStringArray(['hello world', 'fubar!']);
  var ber = writer.buffer;

  t.ok(be