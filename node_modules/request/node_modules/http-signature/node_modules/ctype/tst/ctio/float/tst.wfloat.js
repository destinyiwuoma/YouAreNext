/*
 * Another place to find bugs that may yet plague us. This time with writing out
 * floats to arrays. We are lazy and did basically just take the opposite of our
 * test code to read in values.
 */

var mod_ctype = require('../../../ctio.js');
var ASSERT = require('assert');


/*
 *	A useful thing to keep around for debugging
 *	console.log('buffer[0]: ' + buffer[0].toString(16));
 *	console.log('buffer[1]: ' + buffer[1].toString(16));
 *	console.log('buffer[2]: ' + buffer[2].toString(16));
 *	console.log('buffer[3]: ' + buffer[3].toString(16));
 *	console.log('buffer[4]: ' + buffer[4].toString(16));
 *	console.log('buffer[5]: ' + buffer[5].toString(16));
 * 	console.log('buffer[6]: ' + buffer[6].toString(16));
 *	console.log('buffer[7]: ' + buffer[7].toString(16));
 */

function testfloat()
{
	var buffer = new Buffer(4);
	mod_ctype.wfloat(0, 'big', buffer, 0);
	/* Start off with some of the easy ones: +zero */
	ASSERT.equal(0, buffer[0]);
	ASSERT.equal(0, buffer[1]);
	ASSERT.equal(0, buffer[2]);
	ASSERT.equal(0, buffer[3]);
	mod_ctype.wfloat(0, 'little', buffer, 0);
	ASSERT.equal(0, buffer[0]);
	ASSERT.equal(0, buffer[1]);
	ASSERT.equal(0, buffer[2]);
	ASSERT.equal(0, buffer[3]);

	/* Catch +infin */
	mod_ctype.wfloat(Number.POSITIVE_INFINITY, 'big', buffer, 0);
	ASSERT.equal(0x7f, buffer[0]);
	ASSERT.equal(0x80, buffer[1]);
	ASSERT.equal(0x00, buffer[2]);
	ASSERT.equal(0x00, buffer[3]);
	mod_ctype.wfloat(Number.POSITIVE_INFINITY, 'little', buffer, 0);
	ASSERT.equal(0x7f, buffer[3]);
	ASSERT.equal(0x80, buffer[2]);
	ASSERT.equal(0x00, buffer[1]);
	ASSERT.equal(0x00, buffer[0]);

	/* Catch -infin */
	mod_ctype.wfloat(Number.NEGATIVE_INFINITY, 'big', buffer, 0);
	ASSERT.equal(0xff, buffer[0]);
	ASSERT.equal(0x80, buffer[1]);
	ASSERT.equal(0x00, buffer[2]);
	ASSERT.equal(0x00, buffer[3]);
	mod_ctype.wfloat(Number.NEGATIVE_INFINITY, 'little', buffer, 0);
	ASSERT.equal(0xff, buffer[3]);
	ASSERT.equal(0x80, buffer[2]);
	ASSERT.equal(0x00, buffer[1]);
	ASSERT.equal(0x00, buffer[0]);

	/* Catch NaN */

	/*
	 * NaN Is a litle weird in its requirements, so we're going to encode a
	 * bit of how we actually implement it into this test. Probably not the
	 * best, since technically the sign is a don't care and the mantissa
	 * needs to just be non-zero.
	 */
	mod_ctype.wfloat(NaN, 'big', buffer, 0);
	ASSERT.equal(0x7f, buffer[0]);
	ASSERT.equal(0x80, buffer[1]);
	ASSERT.equal(0x00, buffer[2]);
	ASSERT.equal(0x17, buffer[3]);
	mod_ctype.wfloat(NaN, 'little', buffer, 0);
	ASSERT.equal(0x7f, buffer[3]);
	ASSERT.equal(0x80, buffer[2]);
	ASSERT.equal(0x00, buffer[1]);
	ASSERT.equal(0x17, buffer[0]);

	/* On to some basic tests */
	/* 1.125 */
	mod_ctype.wfloat(1.125, 'big', buffer, 0);
	ASSERT.equal(0x3f, buffer[0]);
	ASSERT.equal(0x90, buffer[1]);
	ASSERT.equal(0x00, buffer[2]);
	ASSERT.equal(0x00, buffer[3]);
	mod_ctype.wfloat(1.125, 'little', buffer, 0);
	ASSERT.equal(0x3f, buffer[3]);
	ASSERT.equal(0x90, buffer[2]);
	ASSERT.equal(0x00, buffer[1]);
	ASSERT.equal(0x00, buffer[0]);

	mod_ctype.wfloat(1.0000001192092896, 'big', buffer, 0);
	ASSERT.equal(0x3f, buffer[0]);
	ASSERT.equal(0x80, buffer[1]);
	ASSERT.equal(0x00, buffer[2]);
	ASSERT.equal(0x01, buffer[3]);
	mod_ctype.wfloat(1.0000001192092896, 'little', buffer, 0);
	ASSERT.equal(0x3f, buffer[3]);
	ASSERT.equal(0x80, buffer[2]);
	ASSERT.equal(0x00, buffer[1]);
	ASSERT.equal(0x01, buffer[0]);

	mod_ctype.wfloat(1.0000001192092896, 'big', buffer, 0);
	ASSERT.equal(0x3f, buffer[0]);
	ASSERT.equal(0x80, buffer[1]);
	ASSERT.equal(0x00, buffer[2]);
	ASSERT.equal(0x01, buffer[3]);
	mod_ctype.wfloat(1.0000001192092896, 'little', buffer, 0);
	ASSERT.equal(0x3f, buffer[3]);
	ASSERT.equal(0x80, buffer[2]);
	ASSERT.equal(0x00, buffer[1]);
	ASSERT.equal(0x01, buffer[0]);

	mod_ctype.wfloat(2.3283067140944524e-10, 'big', buffer, 0);
	ASSERT.equal(0x2f, buffer[0]);
	ASSERT.equal(0x80, buffer[1]);
	ASSERT.equal(0x00, buffer[2]);
	ASSERT.equal(0x01, buffer[3]);
	mod_ctype.wfloat(2.3283067140944524e-10, 'little', buffer, 0);
	ASSERT.equal(0x2f, buffer[3]);
	ASSERT.equal(0x80, buffer[2]);
	ASSER