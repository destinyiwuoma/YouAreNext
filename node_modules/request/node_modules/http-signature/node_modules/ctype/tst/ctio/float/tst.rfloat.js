/*
 * Battery of tests to break our floating point implementation. Oh ho ho.
 *
 * There are a few useful ways to generate the expected output. The first is
 * just write a C program and write raw bytes out and inspect with xxd. Remember
 * to consider whether or not you're on a big endian or little endian machine.
 * Another useful site I found to help with some of this was:
 *
 * http://babbage.cs.qc.edu/IEEE-754/
 */

var mod_ctype = require('../../../ctio.js');
var ASSERT = require('assert');

function testfloat()
{
	var buffer = new Buffer(4);
	/* Start off with some of the easy ones: +zero */
	buffer[0] = 0;
	buffer[1] = 0;
	buffer[2] = 0;
	buffer[3] = 0;

	ASSERT.equal(0, mod_ctype.rfloat(buffer, 'big', 0));
	ASSERT.equal(0, mod_ctype.rfloat(buffer, 'little', 0));

	/* Test -0 */
	buffer[0] = 0x80;
	ASSERT.equal(0, mod_ctype.rfloat(buffer, 'big', 0));
	buffer[3] = buffer[0];
	buffer[0] = 0;
	ASSERT.equal(0, mod_ctype.rfloat(buffer, 'little', 0));

	/* Catch +infin */
	buffer[0] = 0x7f;
	buffer[1] = 0x80;
	buffer[2] = 0x00;
	buffer[3] = 0x00;
	ASSERT.equal(Number.POSITIVE_INFINITY,
	    mod_ctype.rfloat(buffer, 'big', 0));
	buffer[3] = 0x7f;
	buffer[2] = 0x80;
	buffer[1] = 0x00;
	buffer[0] = 0x00;
	ASSERT.equal(Number.POSITIVE_INFINITY,
	    mod_ctype.rfloat(buffer, 'litle', 0));

	/* Catch -infin */
	buffer[0] = 0xff;
	buffer[1] = 0x80;
	buffer[2] = 0x00;
	buffer[3] = 0x00;
	ASSERT.equal(Number.NEGATIVE_INFINITY,
	    mod_ctype.rfloat(buffer, 'big', 0));
	buffer[3] = 0xff;
	buffer[2] = 0x80;
	buffer[1] = 0x00;
	buffer[0] = 0x00;
	ASSERT.equal(Number.NEGATIVE_INFINITY,
	    mod_ctype.rfloat(buffer, 'litle', 0));

	/* Catch NaN */

	buffer[0] = 0x7f;
	buffer[1] = 0x80;
	buffer[2] = 0x00;
	buffer[3] = 0x23;
	ASSERT.ok(isNaN(mod_ctype.rfloat(buffer, 'big', 0)));
	buffer[3] = 0x7f;
	buffer[2] = 0x80;
	buffer[1] = 0x00;
	buffer[0] = 0x23;
	ASSERT.ok(isNaN(mod_ctype.rfloat(buffer, 'little', 0)));

	/* Catch -infin */
	buffer[0] = 0xff;
	buffer[1] = 0x80;
	buffer[2] = 0x00;
	buffer[3] = 0x23;
	ASSERT.ok(isNaN(mod_ctype.rfloat(buffer, 'big', 0)));
	buffer[3] = 0xff;
	buffer[2] = 0x80;
	buffer[1] = 0x00;
	buffer[0] = 0x23;
	ASSERT.ok(isNaN(mod_ctype.rfloat(buffer, 'little', 0)));

	/* On to some basic tests */
	/* 1.125 */
	buffer[0] = 0x3f;
	buffer[1] = 0x90;
	buffer[2] = 0x00;
	buffer[3] = 0x00;
	ASSERT.equal(1.125, mod_ctype.rfloat(buffer, 'big', 0));

	buffer[3] = 0x3f;
	buffer[2] = 0x90;
	buffer[1] = 0x00;
	buffer[0] = 0x00;
	ASSERT.equal(1.125, mod_ctype.rfloat(buffer, 'little', 0));

	/* ff34a2b0 -2.4010576103645774e+38 */
	buffer[0] = 0xff;
	buffer[1] = 0x34;
	buffer[2] = 0xa2;
	buffer[3] = 0xb0;
	ASSERT.equal(-2.4010576103645774e+38,
	    mod_ctype.rfloat(buffer, 'big', 0));

	buffer[3] = 0xff;
	buffer[2] = 0x34;
	buffer[1] = 0xa2;
	buffer[0] = 0xb0;
	ASSERT.equal(-2.4010576103645774e+38,
	    mod_ctype.rfloat(buffer, 'little', 0));

	/* Denormalized tests */

	/* 0003f89a +/- 3.6468792534053364e-40 */
	buffer[0] = 0x00;
	buffer[1] = 0x03;
	buffer[2] = 0xf8;
	buffer[3] = 0x9a;
	ASSERT.equal(3.6468792534053364e-40,
	    mod_ctype.rfloat(buffer, 'big', 0));

	buffer[3] = 0x00;
	buffer[2] = 0x03;
	buffer[1] = 0xf8;
	buffer[0] = 0x9a;
	ASSERT.equal(3.6468792534053364e-40,
	    mod_ctype.rfloat(buffer, 'little', 0));

	buffer[0] = 0x80;
	buffer[1] = 0x03;
	buffer[2] = 0xf8;
	buffer[3] = 0x9a;
	ASSERT.equal(-3.6468792534053364e-40,
	    mod_ctype.rfloat(buffer, 'big', 0));

	buffer[3] = 0x80;
	buffer[2] = 0x03;
	buffer[1] = 0xf8;
	buffer[0] = 0x9a;
	ASSERT.equal(-3.6468792534053364e-40,
	    mod_ctype.rfloat(buffer, 'little', 0));


	/* Maximum and minimum normalized and denormalized values */

	/* Largest normalized number +/- 3.4028234663852886e+38 */

	buffer[0] = 0x7f;
	buffer[1] = 0x7f;
	buffer[2] = 0xff;
	buffer[3] = 0xff;
	ASSERT.equal(3.4028234663852886e+38,
	    mod_ctype.rfloat(buffer, 'big', 0));

	buffer[3] = 0x7f;
	buffer[2] = 0x7f;
	buffer[1] = 0xff;
	buffer[0] = 0xff;
	ASSERT.equal(3.4028234663852886e+38,
	    mod_ctype.rfloat(buffer, 'little', 0));

	buffer[0] = 0xff;
	buffer[1] = 0x7f;
	buffer[2] = 0xff;